from sanic import Sanic
from sanic.response import json, text
import hashlib, secrets, smtplib, os
from datetime import datetime, timedelta, timezone
from email.message import EmailMessage
from dotenv import load_dotenv
from sanic_cors import CORS
import asyncio
from functools import partial
from sanic.exceptions import NotFound
import aiomysql

# -------------------------------------------------
# Ortam deÄŸiÅŸkenlerini yÃ¼kle (.env)
# -------------------------------------------------
load_dotenv()

app = Sanic("Campushub06")
CORS(app)

# -------------------------------------------------
# MySQL connection pool
# -------------------------------------------------
@app.listener("before_server_start")
async def setup_db(app, loop):
    app.ctx.db = await aiomysql.create_pool(
        host=os.getenv("DB_HOST", "127.0.0.1"),
        port=int(os.getenv("DB_PORT", 3306)),
        user=os.getenv("DB_USER", "root"),
        password=os.getenv("DB_PASS", ""),
        db=os.getenv("DB_NAME", "event_management_system"),
        autocommit=True,
        charset="utf8mb4"
    )
    print("âœ… MySQL connection pool hazÄ±r")

@app.listener("after_server_stop")
async def close_db(app, loop):
    app.ctx.db.close()
    await app.ctx.db.wait_closed()
    print("ðŸ”» MySQL connection pool kapandÄ±")


# -------------------------------------------------
# YardÄ±mcÄ± fonksiyonlar
# -------------------------------------------------
async def get_user_by_email(pool, email: str):
    """User tablosundan email ile kullanÄ±cÄ± Ã§ek."""
    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(
                "SELECT user_id, email, password FROM User WHERE email = %s",
                (email,)
            )
            return await cur.fetchone()

def send_email_sync(email, reset_link):
    msg = EmailMessage()
    msg["Subject"] = "CampusHub Ankara - Åžifre SÄ±fÄ±rlama"
    msg["From"] = os.getenv("GMAIL_USER")
    msg["To"] = email
    msg.set_content(
        f"Merhaba,\n\nÅžifreni sÄ±fÄ±rlamak iÃ§in: {reset_link}\n\nCampusHub Ekibi"
    )

    with smtplib.SMTP_SSL("smtp.gmail.com", 465) as smtp:
        smtp.login(os.getenv("GMAIL_USER"), os.getenv("GMAIL_PASS"))
        smtp.send_message(msg)


# -------------------------------------------------
# SSS Verileri (ÅŸimdilik memory)
# -------------------------------------------------
FAQ_ITEMS = [
    {
        "id": 1,
        "question": "CampusHub Ankara nedir?",
        "answer": "CampusHub Ankara, Ankaraâ€™daki Ã¼niversitelerde gerÃ§ekleÅŸen etkinlikleri tek bir platformda toplayan Ã¶ÄŸrenci odaklÄ± bir etkinlik keÅŸif uygulamasÄ±dÄ±r."
    },
    {
        "id": 2,
        "question": "Etkinlikleri nereden buluyorsunuz?",
        "answer": "Etkinlikler Ã¼niversitelerin resmi web siteleri, kulÃ¼p sayfalarÄ± ve sosyal medya hesaplarÄ± Ã¼zerinden toplanarak listelenmektedir."
    },
    {
        "id": 3,
        "question": "Bir etkinliÄŸi takvime nasÄ±l eklerim?",
        "answer": "Etkinlik detay sayfasÄ±nda bulunan 'Takvime Ekle' butonuna tÄ±klayarak etkinliÄŸi kiÅŸisel takviminize ekleyebilirsiniz."
    },
    {
        "id": 4,
        "question": "CampusHub Ankaraâ€™ya Ã¼ye olmam gerekiyor mu?",
        "answer": "Ã‡oÄŸu etkinliÄŸi gÃ¶rmek iÃ§in Ã¼yelik gerekmez. Ancak etkinlik kaydetme ve favorileme gibi Ã¶zellikler iÃ§in Ã¼ye olmanÄ±z gerekir."
    },
    {
        "id": 5,
        "question": "Ãœyelik Ã¼cretli mi?",
        "answer": "HayÄ±r. CampusHub Ankara tamamen Ã¼cretsiz bir platformdur."
    },
    {
        "id": 6,
        "question": "YanlÄ±ÅŸ listelenen bir etkinliÄŸi nasÄ±l bildiririm?",
        "answer": "Etkinlik detay sayfasÄ±ndaki 'Hata Bildir' butonunu kullanarak bize ulaÅŸabilirsiniz."
    },
    {
        "id": 7,
        "question": "Etkinlikler sadece Ankara iÃ§in mi?",
        "answer": "Åžu an sadece Ankara iÃ§in hizmet veriyoruz. Ä°leride diÄŸer ÅŸehirleri de eklemeyi planlÄ±yoruz."
    },
    {
        "id": 8,
        "question": "Kendi kulÃ¼bÃ¼mÃ¼n etkinliÄŸini nasÄ±l ekleyebilirim?",
        "answer": "YakÄ±nda kulÃ¼pler iÃ§in 'OrganizatÃ¶r Paneli' eklenecek. Åžimdilik 'Etkinlik Ekle' formu Ã¼zerinden bize ulaÅŸabilirsiniz."
    },
    {
        "id": 9,
        "question": "Verilerimi nasÄ±l saklÄ±yorsunuz?",
        "answer": "KullanÄ±cÄ± verileri gÃ¼venli sunucularda ve KVKKâ€™ya uygun ÅŸekilde saklanmaktadÄ±r."
    },
    {
        "id": 10,
        "question": "Mobil uygulamanÄ±z var mÄ±?",
        "answer": "Åžu an mobil uyumlu web sitemiz var. Ä°leride Android ve iOS uygulamalarÄ± da yayÄ±nlamayÄ± planlÄ±yoruz."
    },
]


# -------------------------------------------------
# Ana Sayfa
# -------------------------------------------------
@app.get("/")
async def home(request):
    return text("CampusHub backend Ã§alÄ±ÅŸÄ±yor ðŸš€")


# -------------------------------------------------
# KayÄ±t Ol -> User + UserProfile
# -------------------------------------------------
@app.post("/api/kayit-ol")
async def kayit_ol(request):
    data = request.json
    email = data.get("email", "").strip().lower()
    full_name = data.get("name", "").strip()
    password = data.get("password", "")

    if not email or not password or not full_name:
        return json({"basarili": False, "mesaj": "TÃ¼m alanlarÄ± doldurmanÄ±z gerekiyor."}, status=400)

    if len(password) < 6:
        return json({"basarili": False, "mesaj": "Åžifre en az 6 karakter olmalÄ±dÄ±r."}, status=400)

    hashed = hashlib.sha256(password.encode()).hexdigest()

    pool = request.app.ctx.db
    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            # Bu email zaten var mÄ±?
            await cur.execute("SELECT user_id FROM User WHERE email = %s", (email,))
            existing = await cur.fetchone()
            if existing:
                return json({"basarili": False, "mesaj": "Bu e-posta zaten kayÄ±tlÄ±."}, status=409)

            # User tablosuna ekle
            await cur.execute(
                "INSERT INTO User (email, password) VALUES (%s, %s)",
                (email, hashed)
            )
            user_id = cur.lastrowid

            # UserProfile tablosuna isim ekle
            await cur.execute(
                "INSERT INTO UserProfile (user_id, full_name) VALUES (%s, %s)",
                (user_id, full_name)
            )

    return json({"basarili": True, "mesaj": "HesabÄ±nÄ±z baÅŸarÄ±yla oluÅŸturuldu!"}, status=201)


# -------------------------------------------------
# GiriÅŸ
# -------------------------------------------------
@app.post("/api/giris")
async def giris(request):
    data = request.json
    email = data.get("email", "").strip().lower()
    password = data.get("password", "")

    if not email or not password:
        return json({"basarili": False, "mesaj": "E-posta ve ÅŸifre gerekli."}, status=400)

    pool = request.app.ctx.db
    user = await get_user_by_email(pool, email)

    if not user:
        return json({"basarili": False, "mesaj": "Bu e-posta ile kayÄ±t bulunamadÄ±."}, status=404)

    hashed = hashlib.sha256(password.encode()).hexdigest()
    if user["password"] != hashed:
        return json({"basarili": False, "mesaj": "Åžifre yanlÄ±ÅŸ."}, status=401)

    # last_login gÃ¼ncelle
    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute(
                "UPDATE User SET last_login = NOW() WHERE user_id = %s",
                (user["user_id"],)
            )

    return json({"basarili": True, "mesaj": "HoÅŸ geldin!"}, status=200)


# -------------------------------------------------
# Åžifremi Unuttum
# -------------------------------------------------
RESET_TOKENS = {}

@app.post("/api/sifremi-unuttum")
async def sifremi_unuttum(request):
    data = request.json
    email = data.get("email", "").strip().lower()

    if not email:
        return json({"basarili": False, "mesaj": "E-posta girmelisiniz."}, status=400)

    pool = request.app.ctx.db
    user = await get_user_by_email(pool, email)

    if not user:
        return json({"basarili": False, "mesaj": "Bu e-posta sistemde kayÄ±tlÄ± deÄŸil."}, status=404)

    token = secrets.token_urlsafe(32)
    expires_at = datetime.now(timezone.utc) + timedelta(hours=1)
    RESET_TOKENS[token] = {"email": email, "expires_at": expires_at}

    reset_link = f"http://localhost:5173/sifre-sifirla?token={token}"

    try:
        loop = asyncio.get_running_loop()
        await loop.run_in_executor(None, partial(send_email_sync, email, reset_link))
        return json({"basarili": True, "mesaj": "Åžifre sÄ±fÄ±rlama baÄŸlantÄ±sÄ± gÃ¶nderildi."})
    except Exception as e:
        print("Mail gÃ¶nderim hatasÄ±:", e)
        return json({"basarili": False, "mesaj": "E-posta gÃ¶nderilirken hata oluÅŸtu."}, status=500)


# -------------------------------------------------
# Åžifre SÄ±fÄ±rla
# -------------------------------------------------
@app.post("/api/sifre-sifirla")
async def sifre_sifirla(request):
    data = request.json
    token = data.get("token", "")
    new_password = data.get("password", "")

    entry = RESET_TOKENS.get(token)
    now_utc = datetime.now(timezone.utc)

    if not entry or entry["expires_at"] < now_utc:
        return json({"basarili": False, "mesaj": "BaÄŸlantÄ± geÃ§ersiz veya sÃ¼resi dolmuÅŸ."}, status=400)

    if len(new_password) < 6:
        return json({"basarili": False, "mesaj": "Åžifre en az 6 karakter olmalÄ±dÄ±r."}, status=400)

    email = entry["email"]
    hashed = hashlib.sha256(new_password.encode()).hexdigest()

    pool = request.app.ctx.db
    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute(
                "UPDATE User SET password = %s WHERE email = %s",
                (hashed, email)
            )

    del RESET_TOKENS[token]

    return json({"basarili": True, "mesaj": "Åžifreniz baÅŸarÄ±yla sÄ±fÄ±rlandÄ±."}, status=200)


# -------------------------------------------------
# Etkinlikler (Event + EventDate + University)
# -------------------------------------------------
@app.get("/api/etkinlikler")
async def etkinlikler(request):
    """
    TÃ¼m etkinlikleri veya filtrelenmiÅŸ etkinlikleri veritabanÄ±ndan dÃ¶ner.
    Query parametreleri:
      - university  (Ã¼niversite adÄ± - University.name)
      - date        (YYYY-MM-DD formatÄ±nda, EventDate.start_datetime Ã¼zerinden)
    """
    university_name = request.args.get("university")
    date_str = request.args.get("date")

    pool = request.app.ctx.db

    query = """
        SELECT 
            e.event_id AS id,
            e.title,
            e.description,
            e.location,
            uni.name AS university,
            MIN(ed.start_datetime) AS start_datetime,
            MAX(ed.end_datetime) AS end_datetime
        FROM Event e
        LEFT JOIN University uni ON e.university_id = uni.university_id
        LEFT JOIN EventDate ed ON e.event_id = ed.event_id
        WHERE e.is_active = TRUE
    """
    params = []

    if university_name:
        query += " AND uni.name = %s"
        params.append(university_name)

    if date_str:
        query += " AND DATE(ed.start_datetime) = %s"
        params.append(date_str)

    query += """
        GROUP BY e.event_id, e.title, e.description, e.location, uni.name
        ORDER BY e.created_at DESC
    """

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(query, params)
            rows = await cur.fetchall()

    etkinlikler_list = []
    for r in rows:
        if r["start_datetime"]:
            date_out = r["start_datetime"].strftime("%Y-%m-%d")
            time_out = r["start_datetime"].strftime("%H:%M")
        else:
            date_out = None
            time_out = None

        etkinlikler_list.append({
            "id": r["id"],
            "title": r["title"],
            "university": r["university"],
            "location": r["location"],
            "description": r["description"],
            "date": date_out,
            "time": time_out,
        })

    return json({
        "basarili": True,
        "adet": len(etkinlikler_list),
        "etkinlikler": etkinlikler_list
    })


# -------------------------------------------------
# Takvime Ekle -> addEventToFavourite
# -------------------------------------------------
@app.post("/api/takvim/ekle")
async def takvime_ekle(request):
    data = request.json
    email = data.get("email", "").strip().lower()
    event_id = data.get("event_id")

    if not email or not event_id:
        return json({"basarili": False, "mesaj": "Email ve event_id gerekli."}, status=400)

    pool = request.app.ctx.db
    user = await get_user_by_email(pool, email)
    if not user:
        return json({"basarili": False, "mesaj": "KullanÄ±cÄ± bulunamadÄ±."}, status=404)

    async with pool.acquire() as conn:
        async with conn.cursor() as cur:
            await cur.execute("SELECT event_id FROM Event WHERE event_id = %s", (event_id,))
            exists = await cur.fetchone()
            if not exists:
                return json({"basarili": False, "mesaj": "Etkinlik bulunamadÄ±."}, status=404)

            await cur.execute(
                "INSERT IGNORE INTO addEventToFavourite (user_id, event_id) VALUES (%s, %s)",
                (user["user_id"], event_id)
            )

    return json({"basarili": True, "mesaj": "Etkinlik takvime/favorilere eklendi."}, status=200)


# -------------------------------------------------
# KullanÄ±cÄ±nÄ±n takvimi
# -------------------------------------------------
@app.get("/api/takvim")
async def takvim(request):
    email = request.args.get("email", "").strip().lower()

    if not email:
        return json({"basarili": False, "mesaj": "Email gerekli."}, status=400)

    pool = request.app.ctx.db
    user = await get_user_by_email(pool, email)
    if not user:
        return json({"basarili": False, "mesaj": "KullanÄ±cÄ± bulunamadÄ±."}, status=404)

    query = """
        SELECT
            e.event_id AS id,
            e.title,
            e.description,
            e.location,
            uni.name AS university,
            MIN(ed.start_datetime) AS start_datetime,
            MAX(ed.end_datetime) AS end_datetime
        FROM addEventToFavourite f
        JOIN Event e ON f.event_id = e.event_id
        LEFT JOIN University uni ON e.university_id = uni.university_id
        LEFT JOIN EventDate ed ON e.event_id = ed.event_id
        WHERE f.user_id = %s
        GROUP BY e.event_id, e.title, e.description, e.location, uni.name
        ORDER BY e.created_at DESC
    """

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(query, (user["user_id"],))
            rows = await cur.fetchall()

    user_events = []
    for r in rows:
        if r["start_datetime"]:
            date_out = r["start_datetime"].strftime("%Y-%m-%d")
            time_out = r["start_datetime"].strftime("%H:%M")
        else:
            date_out = None
            time_out = None

        user_events.append({
            "id": r["id"],
            "title": r["title"],
            "university": r["university"],
            "location": r["location"],
            "description": r["description"],
            "date": date_out,
            "time": time_out
        })

    return json({
        "basarili": True,
        "adet": len(user_events),
        "etkinlikler": user_events
    })


# -------------------------------------------------
# SSS (FAQ)
# -------------------------------------------------
@app.get("/api/faq")
async def get_all_faqs(request):
    return json({"faqs": FAQ_ITEMS}, status=200)

@app.get("/api/faq/<faq_id:int>")
async def get_single_faq(request, faq_id):
    for item in FAQ_ITEMS:
        if item["id"] == faq_id:
            return json(item, status=200)
    return json({"error": "FAQ bulunamadÄ±."}, status=404)


# -------------------------------------------------
# Feedback API (Feedback tablosu)
# -------------------------------------------------
@app.post("/api/feedback")
async def create_feedback(request):
    data = request.json or {}

    email = (data.get("email") or "").strip().lower()
    event_id = data.get("event_id")
    fb_type = (data.get("type") or "").strip()
    title = (data.get("title") or "").strip()
    message = (data.get("message") or "").strip()

    if not email or not event_id or not message:
        return json({
            "basarili": False,
            "mesaj": "E-posta, etkinlik ve mesaj alanlarÄ± zorunludur."
        }, status=400)

    pool = request.app.ctx.db
    user = await get_user_by_email(pool, email)
    if not user:
        return json({
            "basarili": False,
            "mesaj": "Bu e-posta ile kayÄ±tlÄ± kullanÄ±cÄ± bulunamadÄ±."
        }, status=404)

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(
                "SELECT event_id FROM Event WHERE event_id = %s",
                (event_id,)
            )
            event = await cur.fetchone()
            if not event:
                return json({
                    "basarili": False,
                    "mesaj": "Etkinlik bulunamadÄ±."
                }, status=404)

            await cur.execute(
                """
                INSERT INTO Feedback (user_id, event_id, type, title, message, status)
                VALUES (%s, %s, %s, %s, %s, %s)
                """,
                (user["user_id"], event_id, fb_type or None, title or None, message, "pending")
            )
            feedback_id = cur.lastrowid

    return json({
        "basarili": True,
        "mesaj": "Geri bildiriminiz alÄ±ndÄ±. TeÅŸekkÃ¼r ederiz.",
        "feedback_id": feedback_id
    }, status=201)


@app.get("/api/feedback")
async def list_feedback(request):
    event_id = request.args.get("event_id")
    status = request.args.get("status")

    pool = request.app.ctx.db

    query = """
        SELECT 
            f.feedback_id,
            u.email,
            f.event_id,
            f.type,
            f.title,
            f.message,
            f.status,
            f.created_at
        FROM Feedback f
        JOIN User u ON f.user_id = u.user_id
        WHERE 1=1
    """
    params = []

    if event_id:
        query += " AND f.event_id = %s"
        params.append(event_id)

    if status:
        query += " AND f.status = %s"
        params.append(status)

    query += " ORDER BY f.created_at DESC"

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(query, params)
            rows = await cur.fetchall()

    return json({
        "basarili": True,
        "adet": len(rows),
        "feedbackler": rows
    }, status=200)


# -------------------------------------------------
# CONTACT / Ä°LETÄ°ÅžÄ°M API (DB TABLOLARI Ä°LE)
# -------------------------------------------------

# Statik iÃ§erik endpointleri (header, cards, vs.)
@app.get("/api/contact/header")
async def contact_header(request):
    return json({
        "title": "Bizimle Ä°letiÅŸime GeÃ§",
        "subtitle": (
            "CampusHub Ankara baÄŸÄ±msÄ±z bir Ã¶ÄŸrenci platformudur. "
            "Etkinlik ekleme, Ã¶neri ve geri bildirim iÃ§in "
            "bu sayfadan bizimle iletiÅŸime geÃ§ebilirsin."
        )
    })

@app.get("/api/contact/cards")
async def contact_cards(request):
    return json({
        "cards": [
            {
                "type": "email",
                "title": "E-posta",
                "text": "campushub@ankara.edu.tr",
                "href": "mailto:campushub@ankara.edu.tr",
            },
            {
                "type": "github",
                "title": "GitHub Deposu",
                "text": "AÃ§Ä±k kaynak kodumuzu gÃ¶rÃ¼ntÃ¼leyin ve katkÄ± verin.",
                "href": "https://github.com/campushub-ankara",
            },
        ]
    })

@app.get("/api/contact/club-info")
async def contact_club_info(request):
    return json({
        "title": "KulÃ¼p / Topluluk Musunuz?",
        "text": (
            "Etkinliklerinizi CampusHub Ankara'da listelemek iÃ§in "
            "formdan bizimle iletiÅŸime geÃ§ebilir, kulÃ¼bÃ¼nÃ¼zÃ¼ "
            "platforma ekletmek iÃ§in baÅŸvurabilirsiniz."
        )
    })

@app.get("/api/contact/about")
async def contact_about(request):
    return json({
        "title": "Biz Kimiz?",
        "text": (
            "CampusHub Ankara, Ankaraâ€™daki Ã¼niversite ve kulÃ¼p etkinliklerini "
            "tek bir platformda toplayan, Ã¶ÄŸrenciler tarafÄ±ndan geliÅŸtirilen "
            "baÄŸÄ±msÄ±z bir Ã¶ÄŸrenci giriÅŸimidir. AmacÄ±mÄ±z, sosyal medyayÄ± aktif "
            "kullanmayan Ã¶ÄŸrencilerin de kampÃ¼steki fÄ±rsatlara kolayca "
            "ulaÅŸmasÄ±nÄ± saÄŸlamaktÄ±r."
        )
    })

@app.get("/api/contact/team")
async def contact_team(request):
    return json({
        "title": "CampusHub Ekibi",
        "members": [
            {
                "name": "Ä°layda Ceylan",
                "roles": ["Backend", "CI/CD"],
                "photo": None,
            },
            {
                "name": "Zeynep Bahar ArÄ±k",
                "roles": ["Frontend", "Data Layer", "Testing"],
                "photo": None,
            },
            {
                "name": "Zeynepnaz YÃ¼ksel",
                "roles": ["Backend", "Frontend", "Testing"],
                "photo": None,
            },
            {
                "name": "BuÄŸra KÄ±lÄ±Ã§",
                "roles": ["Backend", "CI/CD"],
                "photo": None,
            },
            {
                "name": "Osman Kapan Mahir",
                "roles": ["Frontend", "Data Layer"],
                "photo": None,
            },
        ]
    })

# Form seÃ§eneklerini DB'den okuyan endpoint
@app.get("/api/contact/form-options")
async def contact_form_options(request):
    """
    ContactUserTypes ve ContactTopicTypes tablolarÄ±ndan
    aktif kullanÄ±cÄ± tipi ve konu tiplerini dÃ¶ner.
    """
    pool = request.app.ctx.db

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            # KullanÄ±cÄ± tipleri
            await cur.execute(
                "SELECT id, label FROM ContactUserTypes WHERE is_active = TRUE ORDER BY id"
            )
            user_types = await cur.fetchall()

            # Konu tipleri
            await cur.execute(
                "SELECT id, label FROM ContactTopicTypes WHERE is_active = TRUE ORDER BY id"
            )
            topic_types = await cur.fetchall()

    return json({
        "user_types": user_types,
        "topic_types": topic_types,
    }, status=200)


@app.get("/api/contact")
async def contact_get(request):
    return json({"ok": True, "message": "Contact endpoint Ã§alÄ±ÅŸÄ±yor!"}, status=200)


# Contact form POST -> ContactMessages tablosuna kaydeder
@app.post("/api/contact")
async def contact_post(request):
    data = request.json or {}

    full_name = (data.get("full_name") or "").strip()
    email = (data.get("email") or "").strip()
    university = (data.get("university") or "").strip()
    user_type_label = (data.get("user_type") or "").strip()
    topic_label = (data.get("topic") or "").strip()
    message_text = (data.get("message") or "").strip()
    consent = data.get("consent", False)

    required_fields = ["full_name", "email", "university", "user_type", "topic", "message"]
    missing = [f for f in required_fields if not data.get(f)]

    if consent is not True:
        missing.append("consent")

    if missing:
        return json({
            "ok": False,
            "error": "Eksik veya doldurulmamÄ±ÅŸ alanlar var.",
            "missing": missing
        }, status=400)

    if "@" not in email:
        return json({"ok": False, "error": "GeÃ§ersiz e-posta adresi."}, status=400)

    pool = request.app.ctx.db

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            # user_type_label -> ContactUserTypes.id
            await cur.execute(
                "SELECT id FROM ContactUserTypes WHERE label = %s AND is_active = TRUE",
                (user_type_label,)
            )
            user_type_row = await cur.fetchone()
            if not user_type_row:
                return json({"ok": False, "error": "GeÃ§ersiz kullanÄ±cÄ± tipi."}, status=400)

            user_type_id = user_type_row["id"]

            # topic_label -> ContactTopicTypes.id
            await cur.execute(
                "SELECT id FROM ContactTopicTypes WHERE label = %s AND is_active = TRUE",
                (topic_label,)
            )
            topic_row = await cur.fetchone()
            if not topic_row:
                return json({"ok": False, "error": "GeÃ§ersiz mesaj tÃ¼rÃ¼."}, status=400)

            topic_type_id = topic_row["id"]

            # ContactMessages tablosuna ekle
            await cur.execute(
                """
                INSERT INTO ContactMessages 
                (full_name, email, university, user_type_id, topic_type_id, message, consent)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                """,
                (full_name, email, university, user_type_id, topic_type_id, message_text, True)
            )
            contact_id = cur.lastrowid

    return json({
        "ok": True,
        "message": "Ä°letiÅŸim formu baÅŸarÄ±yla alÄ±ndÄ±.",
        "contact_id": contact_id
    }, status=201)


# Contact mesajlarÄ±nÄ± DB'den listeleme
@app.get("/api/contact/messages")
async def list_messages(request):
    """
    ContactMessages + tip label'larÄ±yla birlikte listeler.
    Ä°leride admin panelde kullanmak iÃ§in gÃ¼zel olur.
    """
    pool = request.app.ctx.db

    query = """
        SELECT 
            c.contact_id,
            c.full_name,
            c.email,
            c.university,
            ut.label AS user_type,
            tt.label AS topic_type,
            c.message,
            c.consent,
            c.created_at
        FROM ContactMessages c
        LEFT JOIN ContactUserTypes ut ON c.user_type_id = ut.id
        LEFT JOIN ContactTopicTypes tt ON c.topic_type_id = tt.id
        ORDER BY c.created_at DESC
    """

    async with pool.acquire() as conn:
        async with conn.cursor(aiomysql.DictCursor) as cur:
            await cur.execute(query)
            rows = await cur.fetchall()

    return json({
        "ok": True,
        "count": len(rows),
        "messages": rows
    }, status=200)


# -------------------------------------------------
# Ã‡alÄ±ÅŸtÄ±r
# -------------------------------------------------
if __name__ == "__main__":
    app.run(host="127.0.0.1", port=8000, debug=True)
